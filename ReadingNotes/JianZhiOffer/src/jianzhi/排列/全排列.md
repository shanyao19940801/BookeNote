# 数组的全排列

## 全排列的递归实现
全排列表示把集合中元素的所有按照一定的顺序排列起来，使用P(n, n) = n!表示n个元素全排列的个数。P(n, n)中的第一个n表示元素的个数，第二个n表示取多少个元素进行排列。

给定一个n个元素数组，其全排列的过程可以描述如下：<br> 
（1）任意取一个元素放在第一个位置，则有n种选择； <br>
（2）再剩下的n-1个元素中再取一个元素放在第二个位置则有n-1种选择，此时可以看做对n-1个元素进行全排列； <br>
（3）重复第二步，直到对最后一个元素进行全排列，即最后一个元素放在最后一个位置，全排列结束。<br>

以数组{1,2,3}为例，其全排列的过程如下：<br> 
（1）1后面跟（2,3）的全排列； <br>
（2）2后面跟（1,3）的全排列； <br>
（3）3后面跟（1,2）的全排列。<br>

### 递归实现的优缺点
由于递归将问题逐级分解，因此相对比较容易理解，但是需要消耗大量的栈空间，如果函数栈空间不够，那么就运行不下去了，而且函数调用开销也比较大。

### 代码实现

[代码实现](https://github.com/shanyao19940801/BookeNote/blob/master/ReadingNotes/JianZhiOffer/src/jianzhi/%E6%8E%92%E5%88%97/%E6%95%B0%E7%BB%84%E5%85%A8%E6%8E%92%E5%88%97.java)

## 考虑数组元素中有重复的元素

还是以数组{1,2,3}为例，如果数组中有重复的元素，变成了{1,2,2}，那么它的全排列就不能完全按照上面的方法求解，需要做稍微的改动。

因为全排列是将不同元素依次换到当前位置后，再对后面的元素求全排列。如果将重复的元素多次换到当前位置的话，那么就会出现相同的排列。为了避免，我们禁止将相同的元素多次换到当前位置即可。

例如，对{1，2，2}，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。

这样我们也得到了在全排列中去掉重复的规则——**去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换**。

[代码实现](https://github.com/shanyao19940801/BookeNote/blob/master/ReadingNotes/JianZhiOffer/src/jianzhi/%E6%8E%92%E5%88%97/%E6%95%B0%E7%BB%84%E5%85%A8%E6%8E%92%E5%88%97%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE.java)