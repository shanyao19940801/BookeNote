# volatile关键字工作原理

我们知道为了提高处理速度，**处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存**后再进行操作，**但操作完不知道何时会写到内存**。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，**如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题**。所以，在多处理器下，为了保证各个处理器缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

当被关键volatile修饰的变量被修改时，会有下面两个步骤：

1. 将当前处理器缓存行的数据写回到系统内存。
1. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效


## 几个问题

* 被volatile修饰的变量一定是线程安全的吗？

不是，volatile只能保证可见性但并不能保证原子操作

	volatile int i;
	//这里的i并不是 线程安全的，i++并不是一个原子操作
	i++; 

